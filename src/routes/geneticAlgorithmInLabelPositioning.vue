<template>
  <section class="page">
    <article>
      <h1>遗传算法优化标签展示位置</h1>
      <p>作者：<a href="https://blog.gerald.top/posts/genetic-algorithm-in-label-positioning/">Gerald Liu</a></p>
      <blockquote>这篇文章本来想取名叫“遗传算法在数据可视化中的应用”，但是感觉太浮夸了，与我的人设不符，遂作罢。</blockquote>
      <h4>来自nanoid的灵感</h4>
      <p>我第一次发现遗传算法可以应用到前端，是来自<a href="https://twitter.com/sitnikcode/status/1197228880471433217">这条推</a>，讲的是一个热心网友使用遗传算法优化 <a href="https://github.com/ai/nanoid">nanoid</a> 这个库在 <code>gzip</code> 后的大小。</p>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/1.png" alt="">
      <p>推里提到的<a href="https://dev.to/polemius/how-i-reduce-the-size-of-library-with-genetic-algorithm-6m8">这篇文章</a>详细介绍了他的优化过程，大概就是通过遗传算法不断演化，找到了一种字符串的排布方式，使得 <code>nanoid</code> 在 <code>gzip</code> 后比原来小了 <code>2B</code>。</p>
      <p>虽然这件事看上去并没什么卵用，但是却成功激起了我对遗传算法的兴趣。</p>
      <h4>什么是遗传算法</h4>
      <p>遗传算法是基于进化生物学中的一些现象发展起来的，包括遗传、突变、自然选择、杂交等，通过模拟这个过程，将符合预期的一些特征通过“基因”保留下来，从而得到更加接近预期的结果。</p>
      <p>遗传算法的流程大致为：</p>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/2.svg" alt="">
      <p>所以，应用遗传算法的场景需要满足一些前提条件：</p>
      <ul>
        <li><p>每个种群可以编码成一定的数据格式，否则将很难对结果进行评估</p></li>
        <li><p>有一个确切的适应度函数来评价每个种群的好坏，方便后续的过滤和选择</p></li>
        <li><p>通过一定的交叉/突变方法，可以保留一些符合预期的特性，否则就变成了大海捞针，无法通过进化获得更好的结果</p></li>
      </ul>
      <h3>应用</h3>
      <p>刚好我就有一个这样的场景，需要在一些方框旁边合适的位置展示一些标签。</p>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/3.png" alt="">
      <p>方框的位置是会变的，所以我无法提前确定文字标签的位置，需要通过实时的计算来找到一个比较合适的展示方式。</p>
      <h4>问题分析</h4>
      <p>方框的位置和标签的内容是提前给定的，我们要做的是为每个文字标签找到一个合适的位置，让他们满足以下期望：</p>
      <ul>
        <li><p>尽量避免与别的标签或方框有重叠</p></li>
        <li><p>尽量靠近关联的方框</p></li>
        <li><p>在满足以上条件的前提下，优先展示在方框的左上角</p></li>
      </ul>
      <p>再看看上面提到的使用遗传算法的前提条件，看看是否满足：</p>
      <ul>
        <li><p>每个种群的数据编码：我们只需要将所有标签的坐标当成种群的属性即可</p></li>
        <li><p>适应度评价函数：我们要把上面提到的期望转换成代码实现，用来评价当前种群的优劣，理论上可行，具体实现后面再说</p></li>
        <li><p>优秀特性的保留：由于标签的位置是相互影响的，所以当我们选择保留一部分标签的坐标时，他们之间的相对位置就固定了，在后面的种群中，这一部分结果就可以得到保留，从而向预期靠近</p></li>
      </ul>
      <h4>适应度的评价</h4>
      <p>现在我们的重点就是如何来实现评价适应度的方法了。</p>
      <ul>
        <li>
          <p>避免标签与别的标签或方框有重叠。</p>
          <p>我们只需要计算每个标签与其他标签或方框的交叉面积，交叉面积越小，就越符合预期，所以可以将交叉面积的值作为评价的一部分。</p>
        </li>
        <li>
          <p>尽量靠近关联的方框。</p>
          <p>计算标签与关联的方框之间的距离，距离越小，越符合预期。</p>
        </li>
        <li>
          <p>尽量展示在关联方框的左上角。</p>
          <p>这个简单，判断一下当前标签位置离左上角的距离即可。</p>
        </li>
      </ul>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/4.png" alt="">
      <p>所以我最终使用的评价方法为：</p>
      <blockquote>k1 * 重叠面积 + k2 * 标签和方框的间距 + k3 * 标签和方框左上角的距离</blockquote>
      <p>其中 <code>k1</code>、<code>k2</code>、<code>k3</code> 是权重系数，可以根据需要调整。最后分数越小的种群，越符合预期。</p>
      <h4>初始种群的选择</h4>
      <p>接下来，我们要选择一个合适的初始种群，即最初的状态下，标签放在什么位置。</p>

      <p>最初为了省事，我直接将标签放在每个方框的正中央，然后让他们自己变异，移动到合适的位置去。后来发现，从正中间开始变异，会导致前期的很多次变异都无法得到有明显优势的种群，白白浪费了很多次迭代。</p>

      <p>而在前端与用户交互的场景下，<code>JavaScript</code> 的计算时间是很有限的，所以要想办法节省掉这些时间。</p>

      <p>于是我改成了直接将标签放在每个方框的左上角。</p>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/5.png" alt="">
      <h4>变异</h4>
      <p>变异包括交叉和突变两种方式。局部突变可以产生新的特性，有几率得到更优解；交叉则可以更快地结合两个不同种群的优点，当然也有可能是缺点，但那样会被我们的选择方法淘汰，所以最终留下来的应该是优点。</p>
      <p>这里我简单地定义了一下变异的方法：突变就是让标签随机地做一个小范围移动；交叉就是把标签分成两组，交换两个种群的其中半段。</p>
      <h4>优化</h4>
      <p>上面提到，为了快速得到有效的变异，我把标签的初始位置放到了每个方框的左上角。</p>
      <p>这又导致了一个新的问题，如果方框过于拥挤，我们必须要把标签放到方框右侧或是下方，这种方式的弊端就体现出来了，我们需要很多次变异才有可能让标签移到右下方去。</p>
      <p>我首先想到的方法是增加初始种群，对每个标签创建 <code>4</code> 个初始状态，分别定位到方框的四个角上。但是这样会导致种群的数量变成 <code>4^n</code>，效率大大降低。</p>
      <p>利用变异，我找到了一个更简单的方法，增加一种新的突变方式——翻转。变异时有一定几率将标签翻转到方框的另一侧，横向或者纵向翻转，既可以满足位置移动，又避免了大量的无效移动。</p>
      <img src="/static/images/geneticAlgorithmInLabelPositioning/6.png" alt="">
      <p>在这样的条件下，只需 <code>100</code> 个种群构成初始状态，经历 <code>100</code> 个迭代就可以找到一个不错的解了，完全不影响用户体验。</p>
      <p>最终效果见 <a href="https://intellilab.github.io/force/">https://intellilab.github.io/force/</a>。</p>
      <h3>对比</h3>
      <h4>暴力搜索</h4>
      <p>暴力搜索在这个场景下无异于大海捞针，解的空间过于复杂，而且缺乏一个标准来评判最优的解，这会导致搜索的效率低下，而且无法快速收敛，不知道何时可以停下来。</p>
      <p>而使用遗传算法，则可以快速地找到一个良好的解，性价比很高。</p>
      <h4>d3-force</h4>
      <p>这个问题我曾经尝试过使用和 <a href="https://github.com/d3/d3-force">d3-force</a> 类似的方法，最后以失败告终，因为它更适合处理多个点之间的互相影响。而对于有形状的方框，就复杂得多了，我们甚至需要一个物理引擎才能良好地模拟力的作用。</p>

      <p>然而这么复杂的场景，遇到遗传算法就迎刃而解了。</p>

      <h3>总结</h3>
      <p>遗传算法的思想比较简单，通过随机的方法，加上适当的评价函数，可以快速地找到较优解。</p>
      <p>但是也有一些不足，比如种群数目过大或者种群内部的数据过于复杂，会造成性能问题；评价函数的设计比较麻烦，稍有不慎就会导致筛选出来的结果不符合预期。</p>
      <p>总的来看，遗传算法有倾向性的求解方式，很适合一些数据可视化的场景。</p>
      <img class="qr" src="/static/images/qr.jpg" alt="">
    </article>
  </section>
</template>

<script>
  export default {
  }
</script>